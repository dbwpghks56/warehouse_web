// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'question.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

Question _$QuestionFromJson(Map<String, dynamic> json) {
  return _Question.fromJson(json);
}

/// @nodoc
mixin _$Question {
  int get id => throw _privateConstructorUsedError;
  String get title => throw _privateConstructorUsedError;
  String get content => throw _privateConstructorUsedError;
  String get tag => throw _privateConstructorUsedError;
  double get time_limit => throw _privateConstructorUsedError;
  double get memory_limit => throw _privateConstructorUsedError;
  int get level => throw _privateConstructorUsedError;
  double get average_tries => throw _privateConstructorUsedError;
  int get total_tries => throw _privateConstructorUsedError;
  int get total_person => throw _privateConstructorUsedError;
  double get success_rate => throw _privateConstructorUsedError;
  int get total_success => throw _privateConstructorUsedError;
  String get source => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $QuestionCopyWith<Question> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $QuestionCopyWith<$Res> {
  factory $QuestionCopyWith(Question value, $Res Function(Question) then) =
      _$QuestionCopyWithImpl<$Res, Question>;
  @useResult
  $Res call(
      {int id,
      String title,
      String content,
      String tag,
      double time_limit,
      double memory_limit,
      int level,
      double average_tries,
      int total_tries,
      int total_person,
      double success_rate,
      int total_success,
      String source});
}

/// @nodoc
class _$QuestionCopyWithImpl<$Res, $Val extends Question>
    implements $QuestionCopyWith<$Res> {
  _$QuestionCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? title = null,
    Object? content = null,
    Object? tag = null,
    Object? time_limit = null,
    Object? memory_limit = null,
    Object? level = null,
    Object? average_tries = null,
    Object? total_tries = null,
    Object? total_person = null,
    Object? success_rate = null,
    Object? total_success = null,
    Object? source = null,
  }) {
    return _then(_value.copyWith(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as int,
      title: null == title
          ? _value.title
          : title // ignore: cast_nullable_to_non_nullable
              as String,
      content: null == content
          ? _value.content
          : content // ignore: cast_nullable_to_non_nullable
              as String,
      tag: null == tag
          ? _value.tag
          : tag // ignore: cast_nullable_to_non_nullable
              as String,
      time_limit: null == time_limit
          ? _value.time_limit
          : time_limit // ignore: cast_nullable_to_non_nullable
              as double,
      memory_limit: null == memory_limit
          ? _value.memory_limit
          : memory_limit // ignore: cast_nullable_to_non_nullable
              as double,
      level: null == level
          ? _value.level
          : level // ignore: cast_nullable_to_non_nullable
              as int,
      average_tries: null == average_tries
          ? _value.average_tries
          : average_tries // ignore: cast_nullable_to_non_nullable
              as double,
      total_tries: null == total_tries
          ? _value.total_tries
          : total_tries // ignore: cast_nullable_to_non_nullable
              as int,
      total_person: null == total_person
          ? _value.total_person
          : total_person // ignore: cast_nullable_to_non_nullable
              as int,
      success_rate: null == success_rate
          ? _value.success_rate
          : success_rate // ignore: cast_nullable_to_non_nullable
              as double,
      total_success: null == total_success
          ? _value.total_success
          : total_success // ignore: cast_nullable_to_non_nullable
              as int,
      source: null == source
          ? _value.source
          : source // ignore: cast_nullable_to_non_nullable
              as String,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$QuestionImplCopyWith<$Res>
    implements $QuestionCopyWith<$Res> {
  factory _$$QuestionImplCopyWith(
          _$QuestionImpl value, $Res Function(_$QuestionImpl) then) =
      __$$QuestionImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {int id,
      String title,
      String content,
      String tag,
      double time_limit,
      double memory_limit,
      int level,
      double average_tries,
      int total_tries,
      int total_person,
      double success_rate,
      int total_success,
      String source});
}

/// @nodoc
class __$$QuestionImplCopyWithImpl<$Res>
    extends _$QuestionCopyWithImpl<$Res, _$QuestionImpl>
    implements _$$QuestionImplCopyWith<$Res> {
  __$$QuestionImplCopyWithImpl(
      _$QuestionImpl _value, $Res Function(_$QuestionImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? title = null,
    Object? content = null,
    Object? tag = null,
    Object? time_limit = null,
    Object? memory_limit = null,
    Object? level = null,
    Object? average_tries = null,
    Object? total_tries = null,
    Object? total_person = null,
    Object? success_rate = null,
    Object? total_success = null,
    Object? source = null,
  }) {
    return _then(_$QuestionImpl(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as int,
      title: null == title
          ? _value.title
          : title // ignore: cast_nullable_to_non_nullable
              as String,
      content: null == content
          ? _value.content
          : content // ignore: cast_nullable_to_non_nullable
              as String,
      tag: null == tag
          ? _value.tag
          : tag // ignore: cast_nullable_to_non_nullable
              as String,
      time_limit: null == time_limit
          ? _value.time_limit
          : time_limit // ignore: cast_nullable_to_non_nullable
              as double,
      memory_limit: null == memory_limit
          ? _value.memory_limit
          : memory_limit // ignore: cast_nullable_to_non_nullable
              as double,
      level: null == level
          ? _value.level
          : level // ignore: cast_nullable_to_non_nullable
              as int,
      average_tries: null == average_tries
          ? _value.average_tries
          : average_tries // ignore: cast_nullable_to_non_nullable
              as double,
      total_tries: null == total_tries
          ? _value.total_tries
          : total_tries // ignore: cast_nullable_to_non_nullable
              as int,
      total_person: null == total_person
          ? _value.total_person
          : total_person // ignore: cast_nullable_to_non_nullable
              as int,
      success_rate: null == success_rate
          ? _value.success_rate
          : success_rate // ignore: cast_nullable_to_non_nullable
              as double,
      total_success: null == total_success
          ? _value.total_success
          : total_success // ignore: cast_nullable_to_non_nullable
              as int,
      source: null == source
          ? _value.source
          : source // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$QuestionImpl implements _Question {
  _$QuestionImpl(
      {required this.id,
      required this.title,
      required this.content,
      required this.tag,
      required this.time_limit,
      required this.memory_limit,
      required this.level,
      required this.average_tries,
      required this.total_tries,
      required this.total_person,
      required this.success_rate,
      required this.total_success,
      required this.source});

  factory _$QuestionImpl.fromJson(Map<String, dynamic> json) =>
      _$$QuestionImplFromJson(json);

  @override
  final int id;
  @override
  final String title;
  @override
  final String content;
  @override
  final String tag;
  @override
  final double time_limit;
  @override
  final double memory_limit;
  @override
  final int level;
  @override
  final double average_tries;
  @override
  final int total_tries;
  @override
  final int total_person;
  @override
  final double success_rate;
  @override
  final int total_success;
  @override
  final String source;

  @override
  String toString() {
    return 'Question(id: $id, title: $title, content: $content, tag: $tag, time_limit: $time_limit, memory_limit: $memory_limit, level: $level, average_tries: $average_tries, total_tries: $total_tries, total_person: $total_person, success_rate: $success_rate, total_success: $total_success, source: $source)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$QuestionImpl &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.title, title) || other.title == title) &&
            (identical(other.content, content) || other.content == content) &&
            (identical(other.tag, tag) || other.tag == tag) &&
            (identical(other.time_limit, time_limit) ||
                other.time_limit == time_limit) &&
            (identical(other.memory_limit, memory_limit) ||
                other.memory_limit == memory_limit) &&
            (identical(other.level, level) || other.level == level) &&
            (identical(other.average_tries, average_tries) ||
                other.average_tries == average_tries) &&
            (identical(other.total_tries, total_tries) ||
                other.total_tries == total_tries) &&
            (identical(other.total_person, total_person) ||
                other.total_person == total_person) &&
            (identical(other.success_rate, success_rate) ||
                other.success_rate == success_rate) &&
            (identical(other.total_success, total_success) ||
                other.total_success == total_success) &&
            (identical(other.source, source) || other.source == source));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      title,
      content,
      tag,
      time_limit,
      memory_limit,
      level,
      average_tries,
      total_tries,
      total_person,
      success_rate,
      total_success,
      source);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$QuestionImplCopyWith<_$QuestionImpl> get copyWith =>
      __$$QuestionImplCopyWithImpl<_$QuestionImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$QuestionImplToJson(
      this,
    );
  }
}

abstract class _Question implements Question {
  factory _Question(
      {required final int id,
      required final String title,
      required final String content,
      required final String tag,
      required final double time_limit,
      required final double memory_limit,
      required final int level,
      required final double average_tries,
      required final int total_tries,
      required final int total_person,
      required final double success_rate,
      required final int total_success,
      required final String source}) = _$QuestionImpl;

  factory _Question.fromJson(Map<String, dynamic> json) =
      _$QuestionImpl.fromJson;

  @override
  int get id;
  @override
  String get title;
  @override
  String get content;
  @override
  String get tag;
  @override
  double get time_limit;
  @override
  double get memory_limit;
  @override
  int get level;
  @override
  double get average_tries;
  @override
  int get total_tries;
  @override
  int get total_person;
  @override
  double get success_rate;
  @override
  int get total_success;
  @override
  String get source;
  @override
  @JsonKey(ignore: true)
  _$$QuestionImplCopyWith<_$QuestionImpl> get copyWith =>
      throw _privateConstructorUsedError;
}
